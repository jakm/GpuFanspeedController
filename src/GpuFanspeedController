#!/usr/bin/env python3

#Copyright (c) 2012, Jakub Matys <matys.jakub@gmail.com>
#All rights reserved.

import configparser
import io
import logging
import os.path
import signal
import sys
import time
import traceback

import gfcontroller.backends.base
import gfcontroller.core

from gfcontroller.backends import BackendError

LOGGER = logging.getLogger('daemon')

CONFIGFILE = '/etc/gfcontroller.cfg'

DAEMON_SECTION = 'Daemon'
DEVICE_SECTION = 'Device'
SLEEP_OPTION = 'sleep'
DEBUG_OPTION = 'debug'
NAME_OPTION = 'name'
BACKEND_OPTION = 'backend'
LOWEST_SPEED_OPTION = 'lowest_speed'
HIGHEST_SPEED_OPTION = 'highest_speed'
LOWEST_TEMP_OPTION = 'lowest_temp'
HIGHEST_TEMP_OPTION = 'highest_temp'

class DaemonError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class RestartException(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def setup_logging(logfile):
    fmt = '[%(asctime)s] PID=%(process)d: %(name)s %(levelname)s %(message)s'
    logging.basicConfig(format=fmt, level=logging.INFO, filename=logfile)

def start_deamon():
    controllers, sleep = setup()
    LOGGER.debug('Main loop')
    LOGGER.debug('='*30)
    
    while(True):
        for controller in controllers:
            controller.control()
        
        LOGGER.debug('Going sleep')
        LOGGER.debug('='*30)
        time.sleep(sleep)

def setup():
    if not os.path.exists(CONFIGFILE):
        raise DaemonError('Config file %s does not exist.' % CONFIGFILE)
    
    config = configparser.ConfigParser()
    config.read(CONFIGFILE)
    
    if not config.has_section(DAEMON_SECTION):
        raise DaemonError('No Daemon section in config file.')
    
    if len([section for section in config.sections() if section.startswith(DEVICE_SECTION)]) == 0:
        raise DaemonError('No Device section in config file.')
    
    if (config.has_option(DAEMON_SECTION, DEBUG_OPTION) and config.getboolean(DAEMON_SECTION, DEBUG_OPTION) == True):
        logging.root.setLevel(logging.DEBUG)
    
    if not config.has_option(DAEMON_SECTION, SLEEP_OPTION):
        raise DaemonError("Daemon section doesn't contain sleep option.")
    
    sleep = config.getint(DAEMON_SECTION, SLEEP_OPTION)
    
    if sleep <= 0:
        raise DaemonError('Invalid value of sleep option. Use integer > 0.')
    
    LOGGER.debug('Sleep interval: ' + str(sleep))
    LOGGER.debug('-'*30)
    
    controllers = get_controllers(config)
    
    return controllers, sleep

def get_controllers(config):
    controllers = []
    
    for section in config.sections():
        if section == DAEMON_SECTION:
            continue
        
        LOGGER.info('Setting up section %s' %(section,))
        
        tmp = section.split(':')
        if len(tmp) != 2:
            raise DaemonError('Error when parsing device device_id in section %s.' % (section,))
        
        device_id = tmp[1].strip()
        
        device_name = None
        if config.has_option(section, NAME_OPTION):
            device_name = config.get(section, NAME_OPTION)
        
        for option in (BACKEND_OPTION, LOWEST_SPEED_OPTION, LOWEST_TEMP_OPTION, HIGHEST_TEMP_OPTION):
            if not config.has_option(section, option):
                raise DaemonError("Device section %s doesn't contain %s option." %(section, option))
        
        backend_name = config.get(section, BACKEND_OPTION)
        if backend_name not in gfcontroller.backends.NAMES.keys():
            raise DaemonError('Backend named %s is not defined.' % (backend_name,))
        
        backend_module, backend_class = gfcontroller.backends.NAMES[backend_name].split('.')
        backend_module = 'gfcontroller.backends.' + backend_module
        backend = load_backend(backend_module, backend_class)
        
        lowest_speed = config.getint(section, LOWEST_SPEED_OPTION)
        highest_speed = config.getint(section, HIGHEST_SPEED_OPTION)
        lowest_temp = config.getint(section, LOWEST_TEMP_OPTION)
        highest_temp = config.getint(section, HIGHEST_TEMP_OPTION)
        
        controller = gfcontroller.core.GpuFanspeedController(backend(device_id, device_name))
        controller.initialize(lowest_speed, highest_speed, lowest_temp, highest_temp)
        
        controllers.append(controller)
        
        LOGGER.info('Added device: id=%s, backend=%s' % (device_id, repr(backend)))
    
    return controllers

def load_backend(module_name, class_name):
    if not module_name in sys.modules.keys():
        __import__(module_name)
    
    module = sys.modules[module_name]
    
    return get_class(module, class_name)

def get_class(module, class_name):
    LOGGER.debug('Loading class %s in module %s' % (class_name, module.__name__))
    cls = get_class.cache.get((module, class_name), None)
    if cls is None:
        try:
            cls = getattr(module, class_name)
            if not issubclass(cls, gfcontroller.backends.base.GpuBackend):
                raise DaemonError("Class %s is not subclass of GpuBackend" % (class_name,))
            get_class.cache[module, class_name] = cls
        except AttributeError:
            raise DaemonError("Module %s doesn't contain class %s" % (module.__name__, class_name))
    return cls
get_class.cache = {}

def signal_handler(signum, frame):
    if (signum == signal.SIGTERM):
        LOGGER.info('SIGTERM received, exiting.')
        sys.exit(0)
    elif (signum == signal.SIGHUP):
        LOGGER.info('SIGHUP received, restarting daemon.')
        raise RestartException

def main():
    LOGGER.info('Controller started.')
    
    try:
        while(True):
            try:
                start_deamon()
            except RestartException:
                pass
    except KeyboardInterrupt:
        LOGGER.info('User pressed Ctrl-C, exiting.')
    except (DaemonError, BackendError) as e:
        msg = str(e.__class__) + ': ' + str(e)
        LOGGER.error(str(e))
    except Exception as e:
        msg = 'An unhandled exception occured!\n' + str(e.__class__) + ': ' + str(e)
        LOGGER.error(msg)
        buf = io.StringIO()
        traceback.print_exc(file=buf)
        LOGGER.error(buf.getvalue())

if __name__ == '__main__':
    from optparse import OptionParser
    
    parser = OptionParser()
    parser.add_option('-c', '--config-file', dest='configfile', help='use alternative configuration file FILE', metavar='FILE', default=None)
    parser.add_option('-l', '--log-file', dest='logfile', help='use alternative log file FILE', metavar='FILE', default=None)
    
    (options,args) = parser.parse_args()
    
    if options.configfile:
        CONFIGFILE = options.configfile
    
    setup_logging(options.logfile)
    
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGHUP, signal_handler)
    
    main()
